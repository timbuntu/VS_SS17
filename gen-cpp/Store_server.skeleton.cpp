// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Store.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <map>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class StoreHandler : virtual public StoreIf {
public:

    StoreHandler() {
    }

    StoreHandler(std::map<std::string, unsigned int>* itemPrices, std::vector<Order>* orders) {
        
        this->itemPrices = itemPrices;
        this->orders = orders;
        
    }

    int32_t getPrice(const std::string& item) {
        auto it = itemPrices->find(item);
        if(it != itemPrices->end()) {
            return it->second;
        } else {
            return INT_MAX;
        }
    }

    bool order(const std::string& item, const int16_t amount) {
        
        bool success = false;
        auto it = itemPrices->find(item);
        
        if(it != itemPrices->end()) {
            Order order;
            order.item = it->first;
            order.price = it->second;
            order.amount = amount;
            order.total = order.price * order.amount;
            orders->push_back(order);
            success = true;
        }
        
        return success;
    }

    void getReceipt(std::vector<Order> & _return) {
        
        _return = *orders;
        //printf("getReceipt\n");
    }

    static TServer& startStoreServer(int port, std::map<std::string, unsigned int>* itemPrices, std::vector<Order>* orders) {
        shared_ptr<StoreHandler> handler(new StoreHandler(itemPrices, orders));
        shared_ptr<TProcessor> processor(new StoreProcessor(handler));
        shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
        shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
        shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

        TThreadedServer* server = new TThreadedServer(processor, serverTransport, transportFactory, protocolFactory);
        
        std::cout << "StoreServer configured to listen on port " << port << std::endl;
        server->serve();
        return *server;
    }

private:
    std::map<std::string, unsigned int>* itemPrices;
    std::vector<Order>* orders;

};