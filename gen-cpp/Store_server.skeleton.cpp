// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Store.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <map>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class StoreHandler : virtual public StoreIf {
public:

    StoreHandler() {
    }

    StoreHandler(std::string* items, int* prices, unsigned long n) {
        
        for (int i = 0; i < n; i++) {
            itemPrices.insert(std::pair<std::string, int>(items[i], prices[i]));
        }
    }

    int32_t getPrice(const std::string& item) {
        auto it = itemPrices.find(item);
        if(it != itemPrices.end()) {
            return it->second;
        } else {
            return INT_MAX;
        }
        //printf("getPrice\n");
    }

    bool order(const std::string& item, const int16_t amount) {
        
        bool success = false;
        auto it = itemPrices.find(item);
        
        if(it != itemPrices.end()) {
            Order order;
            order.item = it->first;
            order.price = it->second;
            order.amount = amount;
            order.total = order.price * order.amount;
            orders.push_back(order);
            success = true;
        }
        
        //printf("order\n");
        return success;
    }

    void getReceipt(std::vector<Order> & _return) {
        
        _return = orders;
        //printf("getReceipt\n");
    }

    static TServer& startStoreServer(int port, std::string* items, int* prices, unsigned long n) {
        shared_ptr<StoreHandler> handler(new StoreHandler(items, prices, n));
        shared_ptr<TProcessor> processor(new StoreProcessor(handler));
        shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
        shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
        shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

        TThreadedServer* server = new TThreadedServer(processor, serverTransport, transportFactory, protocolFactory);
        server->serve();
        return *server;
    }

private:
    std::map<std::string, unsigned int> itemPrices;
    std::vector<Order> orders;

};